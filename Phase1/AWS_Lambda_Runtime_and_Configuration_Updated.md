---
title: "AWS Lambda Runtime and Configuration â€“ Virtual Agentics"
status: "Stable Draft"
audience: "Internal (Engineering, DevOps, Security); External (Auditors, Stakeholders)"
authors: "VirtualAgentics Core Team (generated by ChatGPT GPT-4.5, curated by Ben)"
version: "1.0"
date: "2025-06-06"
gpt_model: "Drafted by GPT-4.5 Deep Research"
---

# AWS Lambda Runtime and Configuration: Virtual Agentics

## Purpose

This document provides a definitive reference for AWS Lambda runtime environment, configuration standards, and operational constraints as implemented in Phase 1. All settings are managed via IaC and adhere to project naming, security, and scaling guidelines.

---

## 1. Lambda Runtime Selection

- **Runtime:** Python 3.11 (standard for all Phase 1 functions)
  - Rationale: Modern, well-supported, stable AWS runtime; aligns with AI/ML and infra automation ecosystem
- **Dependencies:** Bundled at deploy time using requirements.txt, pip, or poetry (as specified in CI/CD workflow)
- **Handler Function:** All Lambdas use `handler(event, context)` entrypoint, following AWS standard

---

## 2. Memory and Timeout

- **Default memory:** 256 MB (configurable per function)
  - May be increased for functions requiring large LLM/model inferences or data transforms
- **Timeout:** 30 seconds default (configurable up to 5 min if needed per function use-case)
- **Monitoring:** CloudWatch metrics (duration, memory usage) reviewed and adjusted as needed

---

## 3. Environment Variables and Secrets

### Example Terraform Configuration

```hcl
resource "aws_lambda_function" "example_lambda" {
  function_name = "va-prod-example-lambda"
  role          = aws_iam_role.lambda_exec_role.arn
  handler       = "handler.lambda_handler"
  runtime       = "python3.11"
  memory_size   = 256
  timeout       = 30

  environment {
    variables = {
      OPENAI_API_KEY = aws_secretsmanager_secret_version.openai_api_key.secret_string
      DYNAMODB_TABLE = "va-prod-core-dynamodb"
      S3_BUCKET      = "va-prod-content-bucket"
    }
  }

  vpc_config {
    subnet_ids         = [aws_subnet.private_subnet_1.id, aws_subnet.private_subnet_2.id]
    security_group_ids = [aws_security_group.lambda_sg.id]
  }

  filename         = "lambda_function_payload.zip"
  source_code_hash = filebase64sha256("lambda_function_payload.zip")
}

resource "aws_secretsmanager_secret" "openai_api_key" {
  name = "va/prod/openai-api-key"
}

resource "aws_secretsmanager_secret_version" "openai_api_key" {
  secret_id     = aws_secretsmanager_secret.openai_api_key.id
  secret_string = "example-openai-api-key"
}
```


- All secrets/credentials **injected as environment variables** at deploy-time by Terraform or CI/CD pipeline
- **No hardcoded secrets in code**
- Sensitive values (API keys, DB credentials) pulled securely from AWS Secrets Manager at runtime

**Example:**
```json
{
  "OPENAI_API_KEY": "<ref:secretsmanager:openai-api-key>",
  "DYNAMODB_TABLE": "va-prod-core-dynamodb",
  "S3_BUCKET": "va-prod-content-bucket"
}
```

---

## 4. VPC, Networking, and Subnet Selection

### Security Group Configuration (Least Privilege Example)

```hcl
resource "aws_security_group" "lambda_sg" {
  name        = "va-prod-lambda-sg"
  description = "Security group for Lambda functions with least privilege outbound"

  vpc_id = aws_vpc.main_vpc.id

  ingress {
    protocol    = "-1"
    from_port   = 0
    to_port     = 0
    cidr_blocks = []  # No inbound traffic allowed
  }

  egress {
    protocol    = "tcp"
    from_port   = 443
    to_port     = 443
    cidr_blocks = ["0.0.0.0/0"]  # Allow outbound HTTPS only
  }

  tags = {
    Name        = "va-prod-lambda-sg"
    Environment = "prod"
    Project     = "VirtualAgentics"
  }
}
```


- **Default:** Lambda deployed to private subnets as per [AWS_Addressing_Plan.md](../AWS_Addressing_Plan.md) when network access to RDS, VPC endpoints, or internal APIs is needed
- **Internet access:** Via NAT Gateway in public subnet if Lambda needs outbound calls (e.g., to OpenAI API)
- **Security groups:** Strictly least-privilege, allowing only required egress/ingress
- **DNS:** Internal VPC DNS enabled for private resources

---

## 5. IAM Roles and Permissions

- **Each Lambda** assigned a dedicated IAM role following [Naming_Conventions.md](../Naming_Conventions.md)
- **Permissions:** Only required actions (e.g., `dynamodb:PutItem`, `s3:GetObject`, `secretsmanager:GetSecretValue`, `logs:CreateLogStream`)
- **Logging:** All Lambdas write logs to `/aws/lambda/<function-name>` in CloudWatch
- **Environment segregation:** Separate IAM roles for prod, dev, test

---

## 6. Deployment & Artifact Packaging

- **CI/CD:** GitHub Actions builds, zips, and deploys Lambda artifacts on merge to `main`
- **Artifact naming:** `va-prod-contentgen-lambda-<commitid>.zip` or equivalent
- **Layer usage:** Common dependencies packaged as Lambda layers where possible (if shared between functions)
- **S3 staging bucket:** Used as intermediate storage for deployment artifacts

---

## 7. Monitoring, Error Handling, and DLQs

- **CloudWatch Logs:** Enabled by default
- **CloudWatch Alarms:** Set for error count, throttle, and duration (see [Monitoring_and_Alerting.md](../Monitoring_and_Alerting.md))
- **DLQ:** Dead-letter queue configured for failed invocations as needed (SQS or SNS)
- **Retries:** Default AWS retry policy used unless otherwise specified

---

## 8. Resource Tagging

- All Lambda functions and roles **tagged** with:
  - `Name`, `Environment`, `Purpose`, `Project`, `Owner`
- Tagging enforced in Terraform module variables

---

## 9. Security, Compliance, and Updates

- **Runtime updates:** Newer runtimes adopted as AWS/EOL policies require
- **Vulnerability scanning:** All dependencies checked in CI before deploy
- **Least privilege:** IAM and VPC configurations reviewed regularly for over-provisioning
- **Auditability:** All config and changes version-controlled in GitHub

---

## 10. References

- [Lambda_Function_Implementation_Details.md](Lambda_Function_Implementation_Details.md)
- [Naming_Conventions.md](../Naming_Conventions.md)
- [Terraform_Bootstrapping_Phase1.md](Terraform_Bootstrapping_Phase1.md)
- [Monitoring_and_Alerting.md](../Monitoring_and_Alerting.md)
- Source: "AWS Lambda runtime and configuration.pdf"

## Appendix: IAM Roles & Policies (Phase 1)

### Lambda Execution Role Policy Example (General)

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue",
        "dynamodb:PutItem",
        "s3:PutObject",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": [
        "arn:aws:secretsmanager:<region>:<account-id>:secret:va/prod/*",
        "arn:aws:dynamodb:<region>:<account-id>:table/va-prod-core-*",
        "arn:aws:s3:::va-prod-*/*",
        "arn:aws:logs:<region>:<account-id>:log-group:/aws/lambda/va-prod-*:*"
      ]
    }
  ]
}
```

### Cross-Account OIDC IAM Role (GitHub Actions CI/CD)

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::<account-id>:oidc-provider/token.actions.githubusercontent.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "token.actions.githubusercontent.com:sub": "repo:VirtualAgentics/virtualagentics-iac:*"
        }
      }
    }
  ]
}
```

### Control Tower SCP Enforcement (Examples)

- Disallow public S3 bucket creation.
- Require encryption for AWS managed resources.
- Restrict AWS resources to `eu-central-1` region.
- Disallow root user access keys.

These controls are enforced via AWS Control Tower SCPs.

---

*End of document*
